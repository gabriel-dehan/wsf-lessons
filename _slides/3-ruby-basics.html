---
title: Ruby Basics
reveal:
  theme: solarized
  slideNumber: true
  progress: true
  mouseWheel: true
  transition: linear
---

# Les bases de Ruby

---

## Syntaxe

--

### Variables

* Pas de mot clef ou de signe (`$`) spécifique
* Une variable peut contenir n'importe quel type de donnée
* Les noms de variables sont en `snake_case`

```
# Ruby
age = 8
first_name = "Jean"
last_name = 'Neige'

// PHP
$age = 8;
$first_name = "Jean";
$last_name = 'Neige';

// Javascript
var age = 8;
var firstName = "Jean";
var lastName = 'Neige';
```

--

### Boucles - While

```ruby
# Ruby
i = 0;
while i < 10 do
  print i
  i += 1
end
# => 0123456789
```

```php
// PHP
$i = 0;
while ($i < 10) {
  echo $i;
  $i++;
}
// => 0123456789
```
--

### Boucles - Until

L'inverse d'un `while`

- `while` == tant que la condition est vraie
- `until` == jusqu'à ce que la condition soit vraie

```ruby
# Ruby
i = 0;
until i >= 10 do # Jusqu'à ce que i soit supérieur ou égal à 10
  print i
  i += 1
end
# => 0123456789
```

--

### Boucles - Do...While

Exécute les instructions *au moins une fois*
```ruby
# Ruby
i = 0
begin
  print i
end while i > 0
# 0
```

```PHP
// PHP
$i = 0;
do {
  echo $i;
} while ($i > 0);
// 0
```

--

### Boucles - For
```ruby
# Ruby
for i in 0..9
  print i
end
# => 0123456789
```

```PHP
// PHP
for ($i = 0; $i < 10; $i++) {
  echo $i;
}
// => 0123456789
```

--

### Conditions

Attention en Ruby **`else if`** n'existe pas ! On utilise **`elsif`**

```ruby
# Ruby
if age > 70
  puts "You are old !"
elsif age > 18
  puts "You are a grown up !"
else
  puts "Hey kiddo !"
end
```

```php
// PHP
if (age > 70) {
  puts "You are old !"
} else if age > 18 {
  puts "You are a grown up !"
} else {
  puts "Hey kiddo !"
}
```
--

### Conditions (2)

En Ruby *TOUT EST VRAI* sauf `nil` et `false`
```ruby
if 0
  puts true
else
  puts false
end
#=> true
```

```ruby
if "hello"
  puts true
else
  puts false
end
#=> true
```

```ruby
if nil
  puts true
else
  puts false
end
#=> false
```

--

## Conditions ternaires

```ruby
age = 21
is_adult = age > 18 ? true : false
is_adult #=> true
```

```ruby
# Bit more real-worldish
user = App.user_logged_in ? User.first : nil
```

--

### Remarques générales

- Pas de **`;`**
- Les **`()`** sont facultatives
- Pas de **`{}`** mais des **`do`** et **`end`** ou des retours à la ligne

---

## Types de données basiques

--

### En Ruby tout est objet

```ruby
"Roger".class      #=> String
13.class           #=> Fixnum or Integer
3.15.class         #=> Float
true.class         #=> TrueClass
false.class        #=> FalseClass
(1..1000).class    #=> Range
["Roger", 13, 3.15].class #=> Array

```

--

## String

```ruby
"hello world".upcase   #=> "HELLO WORLD"
"Hello" == 'Hello'     #=> true
```

Concatenation

```
num = 1 + 2
"three: " + num.to_s   #=> "three: 3"
'three: ' + num.to_s   #=> 'three: 3'
```

Interpolation

```ruby
"two: #{1 + 1}"    #=> "two: 2"
'two: #{1 + 1}'    #=> "two: #{1 + 1}"
```

Conversion en entier

```ruby
'1984'.class        #=> String
'1984'.to_i         #=> 1984
'1984'.to_i.class   #=> Fixnum

```

--

## Fixnum (Integer)

```ruby
# Standard arithmetic
1 + 2      #=> 3
2 * 4      #=> 8
# Built-in methods
20.even?   #=> true
20.odd?    #=> false
```

Conversion en string

```ruby
1984.to_s    #=> "1984"
```

--

## Float

```
3.1416.truncate   #=> 3
```

--

## Array

```ruby
['Roger', 12, 3.14].size         #=> 3
['Huey', 'Dewey', 'Louie'].sort  #=> ["Dewey", "Huey", "Louie"]
[3, 5, 1].sort  #=> [1, 3, 5]
```

Raccourci syntaxique pour un tableau de Strings

```ruby
%w(Huey Dewey Louie)  #=> ["Huey", "Dewey", "Louie"]
```

--

## Range

```ruby
(1..10).to_a       #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
(1...10).to_a      #=> [1, 2, 3, 4, 5, 6, 7, 8, 9]

('a'..'e').to_a    #=> ['a', 'b', 'c', 'd', 'e']
('A'...'E').to_a   #=> ['A', 'B', 'C', 'D']
```

--

## Récap

```ruby
42         # Fixnum
1.25       # Float
true       # Boolean
('a'..'e') # Range
"hello world"    # String
[ "a", "e", "i"] # Array
```

--

## La doc de Ruby est votre amie !

Vous avez une tâche basique à accomplir ?

* \- Prendre un élément d'un tableau au hasard
* \- Mettre un mot en capitales
* \- Séparer un mot en un tableau de caractères
* \- etc..

<br>
**Par pitié, consultez la documentation**

=> http://www.ruby-doc.org/core-2.3.0/

---

## Types de données avancés

---

## Hash

--

### Définition

```ruby
# Ruby
menu = {
  "Big Mac" => 5,
  "Potatoes" => 2
}

menu.class #=> Hash
menu.keys  #=> ["Big Mac", "Potatoes"]
```

Equivalent aux objets javascript ou à certains tableaux PHP

```PHP
// PHP
$menu = array(
  "Big Mac" => 5,
  "Potatoes" => 2
);
```

```javascript
// Javascript
var menu = {
  "Big Mac": 5,
  "Potatoes": 2
};
```

--

### Lecture

Récupérer une valeur d'un Hash:

```ruby
# On utilise `my_hash[key]` pour y accéder
burger_cost = menu["Big Mac"]
potato_cost = menu["Potatoes"]

puts burger_cost
#=> 5
puts potato_cost
#=> 2

puts "A Big Mac costs #{burger_cost}$ and potatoes are #{potato_cost}$ !"
#=> A Big Mac costs 5$ and potatoes are 2$ !
```

--

### Écriture

Ajouter/modifier une valeur d'un Hash:

```ruby
# On utilise l'opérateur `=`
menu["Big Mac"] = 10
menu["Coca"] = 3

p menu #=> { "Big Mac" => 10, "Potatoes" => 2, "Coca" => 3 }
```

---

## Symbols

--

* \- Un symbole est ~ equivalent à une string sans espace
* \- Un symbole est unique en mémoire
* \- Les symboles sont utilisés en tant qu'identifiants

```ruby
a = "name" #=> String 'name'
b = "name" #=> Different String 'name'

c = :name #=> Symbol :name
d = :name #=> Same Symbol :name
```

--

### Quel intérêt ?

* \- Économiser de la mémoire
* \- Utilisés comme clef de Hash (plus agréable à utiliser)

```ruby
user = {
  :name => "George",
  :age  => 25,
  :country => "France",
  :gender  => "Male"
  :social_security_number => 13498234823842
}

puts user[:name] #=> "George"
puts user[:age]  #=> 25
```

--

### Quel intérêt ? (2)

Permet une syntaxe de Hash simplifiée

```ruby
user = {
  :name => "George",
  :age  => 25
}

puts user[:name] #=> "George"
```

Peut aussi s'écrire

```ruby
user = {
  name: "George",
  age:  25
}

# Automatiquement transformé en
p user #=> { :name => "George", :age => 25 }

puts user[:name] #=> "George"
```

--

### Note sur les hashs

On peut mélanger des clefs symbols et strings:

```ruby
user = {
  name: "George",
  :age => 25,
  "social security number" => 15324234234
}
```
Mais ce mélange est à éviter car peu lisible.

---

## Expressions régulières (Regexp)

--

Ruby comme tout langage permet l'utilisation d'expressions régulières :

```ruby
# Vérifier qu'une string correspond à une regexp
phone_regexp = /(\+33|0)\d{9}/
"0678024353" =~ /\d{11}/ #=> nil
"0678024353" =~ phone_regexp #=> 0
```

```ruby
# Récupérer les matchs d'une regexp
match = "George Abitbol".match /(\w*)\s(\w*)/
match[1] #=> George
match[2] #=> Abitbol
```
